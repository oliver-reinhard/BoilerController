//
//  CBDiscovery.swift
//
//  Created by Owen L Brown on 9/24/14 for Arduino_Servo
//  Copyright (c) 2014 Razeware LLC. All rights reserved.
//
//  Adapted and extended by Oliver Reinhard
//

import Foundation
import CoreBluetooth
import UIKit


public enum CBPeripheralDiscoveryState {
	
	case disabled
	case idle
	case scanning
	case discoveredPeripherals
	case connected
}

public protocol CBAvailabilityObserver : class {
	func peripheralDiscovery(_ discovery : CBPeripheralDiscovery, newState state : CBPeripheralDiscoveryState)
}


open class CBPeripheralDiscovery: NSObject, CBCentralManagerDelegate {
	
	open fileprivate(set) var advertisingUUID : CBUUID!
 	fileprivate var serviceProxies = [CBUUID : GattServiceProxy]()
	
	fileprivate var serviceManager: CBServiceManager?
	fileprivate var centralManager : CBCentralManager!
	open fileprivate(set)  var peripheral : CBPeripheral?
	
	fileprivate var availabilityObservers = [CBAvailabilityObserver]()
	
	open fileprivate(set) var state = CBPeripheralDiscoveryState.disabled {
		didSet {
			print("CentralManager: is \(state)")
			// execute on main thread so UI observers don't get into trouble:
			DispatchQueue.main.async(execute: {
				for obs in self.availabilityObservers {
					obs.peripheralDiscovery(self, newState: self.state)
				}
			})
		}
	}
	
	init(advertisingUUID : CBUUID) {
		super.init()
		self.advertisingUUID = advertisingUUID
		
		let centralQueue = DispatchQueue(label: "boiler-controller", attributes: [])
		centralManager = CBCentralManager(delegate: self, queue: centralQueue)
	}
	
	
	open func addServiceProxy(_ proxy : GattServiceProxy) {
		serviceProxies[proxy.serviceUUID] = proxy
		proxy.service(availabilityDidChange: .uninitialized)
	}
	
	/*
	public func removeServiceProxy(proxy : GattServiceProxy) {
		serviceProxies[proxy.serviceUUID] = nil
		proxy.service(availabilityDidChange: .Uninitialized)
	}
	*/
	
	
	open func startScan() {
		if state == .idle || state == .discoveredPeripherals {
			reset(.scanning)
			centralManager?.scanForPeripherals(withServices: [advertisingUUID], options: nil)
			print("\nCentralManager: Started Scan for advertising UUID \(advertisingUUID)")
		}
	}
	
	
	open func stopScan() {
		if state == .scanning {
			centralManager?.stopScan()
			print("\nCentralManager: Stopped Scan, isScanning = \(centralManager.isScanning)")
			state = peripheral == nil ? .idle : .discoveredPeripherals
		}
	}
	
	open func connectToPeripheral() {
		if state == .discoveredPeripherals {
			centralManager.connect(peripheral!, options: nil)
		}
	}
	
	open func disconnectFromPeripheral() {
		if state == .connected {
			centralManager.cancelPeripheralConnection(peripheral!)
		}
	}
	
	open func addAvailabilityObserver(_ observer : CBAvailabilityObserver) {
		for obs in availabilityObservers {
			if obs === observer {
				return
			}
		}
		availabilityObservers.append(observer)
	}
	
	open func removeAvailabilityObserver(_ observer : CBAvailabilityObserver) {
		for (index, value) in availabilityObservers.enumerated() {
			if value === observer {
				availabilityObservers.remove(at: index)
				break
			}
		}
	}
	
	fileprivate func reset(_ state : CBPeripheralDiscoveryState) {
		self.peripheral = nil
		self.serviceManager?.reset()
		self.state = state
	}
	
	
	// MARK: - CBCentralManagerDelegate
	
	open func centralManagerDidUpdateState(_ central: CBCentralManager) {
		switch (central.state) {
			
		case .unknown:
			// "The current state of the central manager is unknown; an update is imminent." => Wait for another event
			state = .disabled
			
		case .resetting:
			// "The connection with the system service was momentarily lost; an update is imminent." => Reset and wait for another event
			self.reset(.disabled)
			
		case .unsupported:
			// "The platform does not support Bluetooth low energy." => This is the end: indicate to user that the iOS device
			// does not support BLE.
			state = .disabled
			
		case .unauthorized:
			// "The app is not authorized to use Bluetooth low energy." => Tell user to turn on Bluetooth (iOS actually does generate
			// this notification to the user => No need to do anything.
			state = .disabled
			
		case .poweredOff:
			// "Bluetooth is currently powered off." (generated by iOS if user turns off Bluetooth) => Reset and wait for 
			// Bluetooth to become available again
			self.reset(.disabled)
			
		case .poweredOn:
			// "Bluetooth is currently powered on and available to use." (generated by iOS when app starts or when user turns on Bluetooth)
			state = .idle
		}
	}
	
	
	open func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
		
		//
		// For a given scan, this method is called once per device that is being detected.
		// At this time we can handle just a single one and we'll give preference to the first one discovered.
		//
		if self.peripheral == nil || self.peripheral?.state == CBPeripheralState.disconnected {
			print("CentralManager: discovered peripheral \(peripheral.name!), \(peripheral.identifier)")
			self.peripheral = peripheral
			self.serviceManager?.reset()
			
			// stop after the first one discovered
			stopScan()
		}
	}
	
	
	open func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
		
		guard peripheral == self.peripheral else {  // we're only dealing with 1 peripheral here
			return
		}
		print("CentralManager: connected to peripheral \(peripheral.name!), isScanning = \(centralManager.isScanning)")
		state = .connected
		
		// auto-discover services:
		if (serviceManager == nil) {
			serviceManager = CBServiceManager(serviceProxies: serviceProxies)
		}
		serviceManager!.startDiscoveringServices(initWithPeripheral: peripheral)
	}
	
	
	open func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {
		
		guard peripheral == self.peripheral else {	// we're only dealing with 1 peripheral here
			return
		}
		print("CentralManager: failed to connect to peripheral \(peripheral.name!), isScanning = \(centralManager.isScanning)")
		reset(.idle)
		startScan()
	}
	
	
	open func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
		
		guard peripheral == self.peripheral else {	// we're only dealing with 1 peripheral here
			return
		}
		print("CentralManager: disconnected from peripheral \(peripheral.name!), isScanning = \(centralManager.isScanning)")
		reset(.idle)
		startScan()
	}
	
	
	open func centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any]) {
		print("CentralManager: will restore state, isScanning = \(centralManager.isScanning)")
	}
}
